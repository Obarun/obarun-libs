#!/bin/bash
# This script is under license BEER-WARE
# "THE BEER-WARE LICENSE" (Revision 42):
# <eric@obarun.org> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   Eric Vidal

# common functions file for obarun packages

##		Shell color 

unset bold reset red bred green bgreen yellow byellow blue bblue
bold=$(tput bold)
reset=$(tput sgr0)
red=$(tput setaf 1)
bred=${bold}$(tput setaf 1)
green=$(tput setaf 2)
bgreen=${bold}$(tput setaf 2)
yellow=$(tput setaf 3)
byellow=${bold}$(tput setaf 3)
blue=$(tput setaf 4)
bblue=${bold}$(tput setaf 4)


## 		Information display by the script 

echo_bold(){
	local msg=$1; shift 
	printf "${bold}${msg}${reset}\n" "${@}" >&1
}
echo_info(){
	local msg=$1; shift 
	printf "${byellow}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_info_menu(){
	local msg=$1; shift 
	printf "${byellow}${msg} ${reset}\n" "${@}" >&1
}
echo_retry(){
	local msg=$1; shift 
	printf "${bblue}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_valid(){
	local msg=$1; shift 
	printf "${bgreen}    ->${msg} ${reset}\n" "${@}" >&1
}
echo_notvalid(){
	local msg=$1; shift 
	printf "${byellow}    ->${msg} ${reset}\n" "${@}" >&1
}
echo_display(){
	local msg=$1; shift 
	printf "${bold}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_error(){
	local msg=$1; shift 
	printf "${bred}    ->${msg} ${reset}\n" "${@}" >&2
}
answer(){
	echo_retry " Please answer y or n :"
}


## 		Exit
# {1} message to display
# {2} trap functions to call before exit
die (){
	local message _trap
	message="${1}"
	_trap="${2}"
		
	if [[ -n "${message}" ]] ; then
		echo "${bred}==>> Error: ${message}${reset}"
	else
		echo "${bred}==>> Error: Script can not continue"
	fi
	
	${_trap}
	
	exit 1
}

##		Reply functions
## return 0 for yes
## return 1 for no
reply_answer(){
	local reply
	read reply
	while [[ ! "$reply" = @(y|n) ]]; do
		answer
		read reply
	done
	if [ "$reply" == "y" ]; then
		return 0
	else
		return 1
	fi	
}

##		check if a directory is a valid mountpoint
# ${1} directory to check
# return rc=0 on success

check_mountpoint(){
	local _directory
	_directory="${1}"
	
	if mountpoint -q "$_directory"; then
		return 0
	else
		return 1
	fi
	
	unset _directory
}

## 		Mount/unmount filesystem
# $1 name of directory to check 
# $2 action to do : mount/umount

mount_umount(){
	local rep action
	rep="$1"
	action="$2"
	
	_mount(){
		echo_notvalid " Mounting $4"
		mount "$@" 
	}
	
	_umount(){
		echo_notvalid " Unmounting $1"
		umount $@
	}
			
	if [[ "$action" == "mount" ]]; then
		echo_display " Check mounted filesystem on $rep"
		if ! [[ $(mount | grep "$rep"/proc) ]]; then
			_mount -t proc proc "$rep/proc" -o nosuid,noexec,nodev 
			_mount -t sysfs sys "$rep/sys" -o nosuid,noexec,nodev 
			_mount -t devtmpfs dev "$rep/dev" -o mode=0755,nosuid
			_mount -t devpts devpts "$rep/dev/pts" -o mode=0620,gid=5,nosuid,noexec
			_mount -t tmpfs shm "$rep/dev/shm" -o mode=1777,nosuid,nodev
			_mount -t tmpfs run "$rep/run" -o nosuid,nodev,mode=0755
			_mount -t tmpfs tmp "$rep/tmp" -o mode=1777,strictatime,nodev,nosuid
		else
			echo_valid " Filesystem already mounted in ${rep}"
		fi
	fi
	if [[ "$action" == "umount" ]]; then
		echo_display " Check mounted filesystem"
		if [[ $(mount | grep "$rep"/proc) ]]; then
			_umount "$rep/proc"
			_umount "$rep/sys"
			_umount "$rep/dev/pts"
			_umount "$rep/dev/shm"
			_umount "$rep/run"
			_umount "$rep/tmp"
			_umount "$rep/dev"
		else
			echo_valid " Filesystem not mounted in ${rep}"
		fi
	fi
	unset rep action
}

## 		Check list option

check_elements(){
	for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

##		Generate fstab
# ${1} mountpoint directory

gen_fstab(){
	local _directory
	_directory="${1}"
	
	echo_display " Generate fstab"
	genfstab -p "$_directory" > "$_directory/etc/fstab" || die " Impossible to generate fstab"

	unset _directory
}

#		Edit a file
# ${1} name of the file to edit
# ${2} path to the named file
# ${3} name of the editor program

edit_file(){
	local _path _file _editor
	_file="${1}"
	_path="${2}"
	_editor="${3}"
	
	"$_editor" "$_path"/"$_file"

	unset _path _file _editor
}

##		Generate key

# {1} name to populate e.g. "obarun" or a list "archlinux obarun"
# {2} gpg directory to use, can be empty

pac_key(){
	
	local gpg_opts named 
	local -a name_to_populate
	
	name_to_populate=( "$1" )

	if [[ ! -z "$2" ]]; then
		gpg_opts="--gpgdir $2"
	fi
	
	echo_display " Start pacman-key"
	haveged -w 1024
	
	pacman-key --init $gpg_opts
	
	for named in ${name_to_populate[@]};do
		echo_notvalid "populate $named"
		pacman-key --populate "$named" "$gpg_opts"
	done
	
	#kill all process before existing, this avoid trouble to umount the rootdir
	kill_process "gpg-agent"
	
	unset gpg_opts named name_to_populate
}

# ${1} gpg directory to use, can be empty
check_gpg(){
	
	local gpg_opts named 
		
	if [[ ! -z "$1" ]]; then
		gpg_opts="--gpgdir $1"
	fi
	
	echo_display " Check if gpg key exist"	
	pacman-key -u $gpg_opts &>/dev/null
	
	if (( $? ));then
		echo_notvalid " Gpg doesn't exist, create it..."
		if [[ ! -z $gpg_opts ]]; then
			pac_key "obarun archlinux" "$gpg_opts"
		else
			pac_key "obarun archlinux"
		fi
	else
		echo_valid " Gpg key exist, Refresh it..."
		pacman-key -u $gpg_opts
	fi
	
	unset gpg_opts
}

# ${1} key or list of key to add e.g "7B45DAAC" or "7B45DAAC 0375F9B2"
# ${2} gpg directory to use, can be empty
add_gpg(){
	local gpg_opts named 
	local -a key_to_add
	
	key_to_add=( "$1" )
	
	if [[ ! -z "$2" ]]; then
		gpg_opts="--gpgdir $2"
	fi
	
	# pacman-key -r failed without /root/.gnupg
	# create it by dirmngr
	# TODO: find a turn around
	if [[ ! -d /root/.gnupg ]]; then
		dirmngr --daemon &>/dev/null #& kill_process "dirmngr"
	fi
	
	# start haveged to speed up the process
	haveged -w 1024
	
	# add the specified key
	if [[ ! -z ${key_to_add[@]} ]]; then
		for named in ${key_to_add[@]}; do
			echo_display " Check if $named gpg signature exist"
			if ! pacman-key --list-keys "$named" $gpg_opts &>/dev/null; then
				echo_notvalid " Add $named gpg signature, please wait"
				pacman-key -r "$named" $gpg_opts
				pacman-key --lsign-key "$named" $gpg_opts
			else
				echo_valid " $named gpg signature already exist"
			fi
		done
	fi
	
	kill_process "dirmngr gpg-agent"
	
	unset gpg_opts named key_to_add
}

# {1} process e.g. "haveged" or list of process to kill e.g. "haveged dirmngr" 
kill_process(){
	local named
	local -a list_of_process
	list_of_process=( "$1" )
	
	for named in ${list_of_process[@]}; then
		killall -r $named 2>/dev/null
	done
	
	unset named list_of_process
}

## 		Create temporary users
# ${1} user name to create

user_add(){
	
	local named
	named="${1}"
	
	if ! [[ $(awk -F':' '{ print $1}' /etc/passwd | grep ${named}) ]]; then
		echo_display " Create the ${named} user"
		useradd -m -g users -G "wheel,disk,storage,optical,floppy,network" -s /bin/bash "${named}"
	fi
	
	unset named
}

# ${1} user name to delete

user_del(){
	
	local named
	named="${1}"
	
	echo_display " Removing user : ${named}"
	userdel -r ${named} 
		
	unset named
}
# ${1} path to the file
# ${2} name of the file
# ${3} searched on to the file
# return 0 on success, 1 on fail
search_in_file(){
	local path_file named search line_ in_file
	path_file="${1}"
	named="${2}"
	search="${3}"
	in_file="${path_file}/${named}"
	
	while read line_;do
		case $line_ in
			$search) rc=0 && break ;;
			*) rc=1 ;;
		esac
	done < "${in_file}"
	if [[ $rc == 0  ]]; then
		unset rc
		return 0
	else
		unset rc
		return 1
	fi 
	unset path_file named search line_ in_file
}
##		Update package automaticaly

# ${1} name of the package to update
# ${2} working directory to store the data
# ${3} address to the git repository

pac_update(){
	
	local status _pkgname build_dir rc work_dir _olpwd _adress
	_pkgname="${1}"
	work_dir="${2}"
	_adress="${3}"
	_oldpwd=`pwd`
	_tmpdir=$(mktemp -d /tmp/$_pkgname.XXXXXX)
	rc=0
	
	echo_display " Check $_pkgname version"
	
	# make build_dir directory
	make_build_dir(){
		if ! [ -d "$work_dir/update_package" ]; then
			echo_notvalid " Create necessary directory"
			mkdir -p -m0755 "$work_dir/update_package"
			build_dir="$work_dir/update_package"
		else
			build_dir="$work_dir/update_package"
		fi
	}
	
	# check if pkgbuild exist
	copy_pkgbuild(){
		echo_notvalid " Copy PKGBUILD to ${green}[$build_dir/$_pkgname] to ${green}[$build_dir]${reset}"
		cp -f "$build_dir/$_pkgname"/PKGBUILD "$build_dir"/PKGBUILD
	}
	
	# make package
	make_package(){
		user_add "usertmp"
		#copy_pkgbuild || die " Impossible to copy PKGBUILD"
		chown -R usertmp:users "$build_dir"
		cd "$build_dir/$_pkgname"
		echo_notvalid " Launch makepkg and install the new version if exist"
		su usertmp -c "makepkg -Cfi --nosign --noconfirm --needed"
		sleep 2
	}
	
	# check git repositories
	check_update(){
		cd "$build_dir/$_pkgname"
	
		# check the remote branch
		git fetch origin || die " Impossible to fetch origin"	
			
		# emtpy status variable means up to date
		status=$(git diff master origin/master)
		
		if [[ -z "${status}" ]]; then
			echo_valid " Git already up to date, nothing to do"
			return 0
			sleep 2
		else
			# local is out of date, update it
			echo_notvalid " Local branch is out-of-date, update it..."
			git merge origin/master || die " Impossible merge origin to master branch"	
			return 1
		fi
	}
	
	# check current version 
	check_version(){
		cd "$build_dir/$_pkgname"
		local curr_version git_version
		curr_version=$(pacman -Qi $_pkgname | grep "Version" | awk -F": " '{print $2}' | sed 's:-1::')
		git_version=$(git rev-parse --short HEAD)
		
		check_update #|| die " Impossible to udpdate $_pkgname"
		
		if (( $? )); then
			echo_display " $_pkgname is out of date, updating please wait"
			make_package || die " Impossible to make the package"
			rc=1
		fi
		if ! [[ "$curr_version" == "$git_version" ]]; then
			if [[ $rc == 1 ]]; then
				unset rc
			else
				make_package || die " Impossible to make the package"
			fi
		fi
	}	
		
	make_build_dir
	
	if ! [ -d "$build_dir/$_pkgname" ]; then
		cd "$build_dir"
		echo_notvalid " Clone repository form ${green}[$git_addr]${reset}"
		git clone "$_adress"
		make_package || die " Impossible to make the package"
	else
		check_version || die " Impossible to check the current version"
	fi	
	
	cd $_oldpwd
	
	unset status _pkgname build_dir rc work_dir _olpwd _adress
}

# ${1} path directories
# ${2} name of directory
# ${3} searched files
# return 0 success, 1 fail
search_in_dir(){
	local path_dir search named here rc
	local -a list 
	path_dir="${1}"
	named="${2}"
	search="${3}"
	
	mapfile -t list < <(ls --group-directories-first ${path_dir}/${named})
	
	for here in "${list[@]}"; do
		case $here in
				$search) rc=0 && break ;;
				*) rc=1 ;;
			esac
		
	done
	if [[ $rc == 0  ]]; then
		unset rc
		return 0
	else
		unset rc
		return 1
	fi
	
	unset path_dir search named sub_dir list here rc
}

# ${1} path to the file
# ${2} name of the file
# ${3} searched on to the file
# return 0 on success, 1 on fail
search_in_file(){
	local path_file named search line_ in_file
	path_file="${1}"
	named="${2}"
	search="${3}"
	in_file="${path_file}/${named}"
	
	while read line_;do
		case $line_ in
			$search) rc=0 && break ;;
			*) rc=1 ;;
		esac
	done < "${in_file}"
	
	if [[ $rc == 0  ]]; then
		unset rc
		return 0
	else
		unset rc
		return 1
	fi
	
	unset path_file named search line_ in_file
}

# ${1} option to pass
# ${2} target 
# ${3} where to create it
# ${4} name of the symlinks
make_symlinks(){
	local opt target where named
	opt="${1}"
	target="${2}"
	where="${3}"
	named="${4}"

	ln "${opt}" "${target}" "${where}/${named}"

	unset opt target where named
}

# ${1} name of the directory
# return 0 on success, 1 for fail
check_dir(){
	local dir
	dir="${1}"
	
	if [[ -d "${dir}" ]]; then
		return 0
	else
		return 1
	fi
	
	unset dir
}
